<!doctype html><html lang=ja-jp dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>MembraneAutomata | みつよし手稿</title><meta name=keywords content="homeostasis,cellular_automata,membrane_automata,research"><meta name=description content="これは学生の頃、連休中に思い立って書き上げたMacアプリケーションです。
10年以上前の実装にも関わらず現行マシンで問題なくコンパイルできました。実装言語のObjective-CとCに大きな更新がなかったためかな？
当時はパターンが収束してしまうことがわかり触るのをやめてしまったのですが、モデルの筋はいい気がするのでパラメータを変えて自動探索にかけたらなにか生まれそうな気がします。
概要 生命現象の土台となる恒常性をもつパターンが現れうる系を作成しました。今回はモデルと計算の簡便さから、系の基本構造にはセルオートマトンを採用しました。セルオートマトンはConway&rsquo;s Game of Life[^1]に代表されるように、単純なモデルを比較的少ない計算量で実行できる便利な計算モデルです。しかしパターンの恒常性の観点から考えると、ひとつのセルの状態が反転しただけで崩壊するような不安定なモデルに恒常性をもたせるのは困難です。MembraneAutomataでは近傍半径を増やす[^2]ことで頑強なパターン構築を可能にしました。そしてMNCAの上で、恒常性のある領域を外界から隔離するために、泡状の構造が生成される簡易化学モデルを実装しました。
^1: Conway&rsquo;s Game of Life - Wikipedia
^2: Multiple Neighbourhood Cellular Automata (MNCA)と呼ばれる。Understanding Multiple Neighbourhood Cellular Automata
Motivation of Current Work 私は生命のもつ予測不能性を再現するというテーマを研究しており、この作品はそのテーマのうえで、恒常性の創発に主眼を置いて作ったものです。予測不能性という制約のもとで設計するためには、実現したい現象（ここでは恒常性）を直接実装するのではなく、下位の現象を実装することを介して、実現したい上位の現象を創発する、という手法をとる必要があります。本作ではセルオートマトンの状態遷移ルールを適切に設定することによりそれを実現しました。
要件 系の要件 a. 比較的単純かつ小規模な計算で実現できること b. 現れるパターンがConway&rsquo;s Game of Lifeより安定していること a.モデルの単純さと計算しやすさの要件からセルオートマトンを選択し、b.パターン安定の要件から近傍半径を増やして近傍セルひとつあたりのパターンへの影響度を小さくすることにしました。
セルオートマトンのルール要件 c. 恒常性をもつパターンが発生しうること c1. 系全体では、自然な行いに任せていると秩序が失われること（現実世界でのエントロピーの増大則と同等の仕組み） c2. そのような系のなかで、外界に影響されない区画が存在すること c21. その区画の境界部分が外界の影響を打ち消し、内部に伝えない役割を果たすこと 現実の現象を参考にこれらの要件を満たすルールを考えると、水中の油滴、あるいは泡を抽象化することで理解しやすいモデルを作れそうに思えます。泡状のパターンの境界付近で外界の影響を打ち消し、内部に恒常性をつくる、という構造です。
実装仕様 実装: MembraneAutomata - GitHub
MNCAの実装 MembraneAutomataで実装するMNCAは近傍半径を2以上に拡張したものです。自セルの次の状態に影響する近傍セル数 n 近傍半径を r と置いたとき
n = (r * (r + 1)) * 4"><meta name=author content><link rel=canonical href=https://mitsuyoshi-yamazaki.github.io/ja-jp/posts/2022-07-30-174703.671472/><link crossorigin=anonymous href=/assets/css/stylesheet.d7fb4cbf980fe688a21621b06a795933c4e6bb2d4070ec940667af1715d84af2.css integrity="sha256-1/tMv5gP5oiiFiGwanlZM8Tmuy1AcOyUBmevFxXYSvI=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://mitsuyoshi-yamazaki.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://mitsuyoshi-yamazaki.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://mitsuyoshi-yamazaki.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://mitsuyoshi-yamazaki.github.io/apple-touch-icon.png><link rel=mask-icon href=https://mitsuyoshi-yamazaki.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=ja-jp href=https://mitsuyoshi-yamazaki.github.io/ja-jp/posts/2022-07-30-174703.671472/><link rel=alternate hreflang=en href=https://mitsuyoshi-yamazaki.github.io/posts/2022-07-30-174703.671472/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-3EB73WSJ9K"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-3EB73WSJ9K",{anonymize_ip:!1})}</script><meta property="og:title" content="MembraneAutomata"><meta property="og:description" content="これは学生の頃、連休中に思い立って書き上げたMacアプリケーションです。
10年以上前の実装にも関わらず現行マシンで問題なくコンパイルできました。実装言語のObjective-CとCに大きな更新がなかったためかな？
当時はパターンが収束してしまうことがわかり触るのをやめてしまったのですが、モデルの筋はいい気がするのでパラメータを変えて自動探索にかけたらなにか生まれそうな気がします。
概要 生命現象の土台となる恒常性をもつパターンが現れうる系を作成しました。今回はモデルと計算の簡便さから、系の基本構造にはセルオートマトンを採用しました。セルオートマトンはConway&rsquo;s Game of Life[^1]に代表されるように、単純なモデルを比較的少ない計算量で実行できる便利な計算モデルです。しかしパターンの恒常性の観点から考えると、ひとつのセルの状態が反転しただけで崩壊するような不安定なモデルに恒常性をもたせるのは困難です。MembraneAutomataでは近傍半径を増やす[^2]ことで頑強なパターン構築を可能にしました。そしてMNCAの上で、恒常性のある領域を外界から隔離するために、泡状の構造が生成される簡易化学モデルを実装しました。
^1: Conway&rsquo;s Game of Life - Wikipedia
^2: Multiple Neighbourhood Cellular Automata (MNCA)と呼ばれる。Understanding Multiple Neighbourhood Cellular Automata
Motivation of Current Work 私は生命のもつ予測不能性を再現するというテーマを研究しており、この作品はそのテーマのうえで、恒常性の創発に主眼を置いて作ったものです。予測不能性という制約のもとで設計するためには、実現したい現象（ここでは恒常性）を直接実装するのではなく、下位の現象を実装することを介して、実現したい上位の現象を創発する、という手法をとる必要があります。本作ではセルオートマトンの状態遷移ルールを適切に設定することによりそれを実現しました。
要件 系の要件 a. 比較的単純かつ小規模な計算で実現できること b. 現れるパターンがConway&rsquo;s Game of Lifeより安定していること a.モデルの単純さと計算しやすさの要件からセルオートマトンを選択し、b.パターン安定の要件から近傍半径を増やして近傍セルひとつあたりのパターンへの影響度を小さくすることにしました。
セルオートマトンのルール要件 c. 恒常性をもつパターンが発生しうること c1. 系全体では、自然な行いに任せていると秩序が失われること（現実世界でのエントロピーの増大則と同等の仕組み） c2. そのような系のなかで、外界に影響されない区画が存在すること c21. その区画の境界部分が外界の影響を打ち消し、内部に伝えない役割を果たすこと 現実の現象を参考にこれらの要件を満たすルールを考えると、水中の油滴、あるいは泡を抽象化することで理解しやすいモデルを作れそうに思えます。泡状のパターンの境界付近で外界の影響を打ち消し、内部に恒常性をつくる、という構造です。
実装仕様 実装: MembraneAutomata - GitHub
MNCAの実装 MembraneAutomataで実装するMNCAは近傍半径を2以上に拡張したものです。自セルの次の状態に影響する近傍セル数 n 近傍半径を r と置いたとき
n = (r * (r + 1)) * 4"><meta property="og:type" content="article"><meta property="og:url" content="https://mitsuyoshi-yamazaki.github.io/ja-jp/posts/2022-07-30-174703.671472/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-07-30T17:47:03+09:00"><meta property="article:modified_time" content="2022-07-30T17:47:03+09:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="MembraneAutomata"><meta name=twitter:description content="これは学生の頃、連休中に思い立って書き上げたMacアプリケーションです。
10年以上前の実装にも関わらず現行マシンで問題なくコンパイルできました。実装言語のObjective-CとCに大きな更新がなかったためかな？
当時はパターンが収束してしまうことがわかり触るのをやめてしまったのですが、モデルの筋はいい気がするのでパラメータを変えて自動探索にかけたらなにか生まれそうな気がします。
概要 生命現象の土台となる恒常性をもつパターンが現れうる系を作成しました。今回はモデルと計算の簡便さから、系の基本構造にはセルオートマトンを採用しました。セルオートマトンはConway&rsquo;s Game of Life[^1]に代表されるように、単純なモデルを比較的少ない計算量で実行できる便利な計算モデルです。しかしパターンの恒常性の観点から考えると、ひとつのセルの状態が反転しただけで崩壊するような不安定なモデルに恒常性をもたせるのは困難です。MembraneAutomataでは近傍半径を増やす[^2]ことで頑強なパターン構築を可能にしました。そしてMNCAの上で、恒常性のある領域を外界から隔離するために、泡状の構造が生成される簡易化学モデルを実装しました。
^1: Conway&rsquo;s Game of Life - Wikipedia
^2: Multiple Neighbourhood Cellular Automata (MNCA)と呼ばれる。Understanding Multiple Neighbourhood Cellular Automata
Motivation of Current Work 私は生命のもつ予測不能性を再現するというテーマを研究しており、この作品はそのテーマのうえで、恒常性の創発に主眼を置いて作ったものです。予測不能性という制約のもとで設計するためには、実現したい現象（ここでは恒常性）を直接実装するのではなく、下位の現象を実装することを介して、実現したい上位の現象を創発する、という手法をとる必要があります。本作ではセルオートマトンの状態遷移ルールを適切に設定することによりそれを実現しました。
要件 系の要件 a. 比較的単純かつ小規模な計算で実現できること b. 現れるパターンがConway&rsquo;s Game of Lifeより安定していること a.モデルの単純さと計算しやすさの要件からセルオートマトンを選択し、b.パターン安定の要件から近傍半径を増やして近傍セルひとつあたりのパターンへの影響度を小さくすることにしました。
セルオートマトンのルール要件 c. 恒常性をもつパターンが発生しうること c1. 系全体では、自然な行いに任せていると秩序が失われること（現実世界でのエントロピーの増大則と同等の仕組み） c2. そのような系のなかで、外界に影響されない区画が存在すること c21. その区画の境界部分が外界の影響を打ち消し、内部に伝えない役割を果たすこと 現実の現象を参考にこれらの要件を満たすルールを考えると、水中の油滴、あるいは泡を抽象化することで理解しやすいモデルを作れそうに思えます。泡状のパターンの境界付近で外界の影響を打ち消し、内部に恒常性をつくる、という構造です。
実装仕様 実装: MembraneAutomata - GitHub
MNCAの実装 MembraneAutomataで実装するMNCAは近傍半径を2以上に拡張したものです。自セルの次の状態に影響する近傍セル数 n 近傍半径を r と置いたとき
n = (r * (r + 1)) * 4"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":4,"name":"MembraneAutomata","item":"https://mitsuyoshi-yamazaki.github.io/ja-jp/posts/2022-07-30-174703.671472/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"MembraneAutomata","name":"MembraneAutomata","description":"これは学生の頃、連休中に思い立って書き上げたMacアプリケーションです。\n10年以上前の実装にも関わらず現行マシンで問題なくコンパイルできました。実装言語のObjective-CとCに大きな更新がなかったためかな？\n当時はパターンが収束してしまうことがわかり触るのをやめてしまったのですが、モデルの筋はいい気がするのでパラメータを変えて自動探索にかけたらなにか生まれそうな気がします。\n概要 生命現象の土台となる恒常性をもつパターンが現れうる系を作成しました。今回はモデルと計算の簡便さから、系の基本構造にはセルオートマトンを採用しました。セルオートマトンはConway\u0026rsquo;s Game of Life[^1]に代表されるように、単純なモデルを比較的少ない計算量で実行できる便利な計算モデルです。しかしパターンの恒常性の観点から考えると、ひとつのセルの状態が反転しただけで崩壊するような不安定なモデルに恒常性をもたせるのは困難です。MembraneAutomataでは近傍半径を増やす[^2]ことで頑強なパターン構築を可能にしました。そしてMNCAの上で、恒常性のある領域を外界から隔離するために、泡状の構造が生成される簡易化学モデルを実装しました。\n^1: Conway\u0026rsquo;s Game of Life - Wikipedia\n^2: Multiple Neighbourhood Cellular Automata (MNCA)と呼ばれる。Understanding Multiple Neighbourhood Cellular Automata\nMotivation of Current Work 私は生命のもつ予測不能性を再現するというテーマを研究しており、この作品はそのテーマのうえで、恒常性の創発に主眼を置いて作ったものです。予測不能性という制約のもとで設計するためには、実現したい現象（ここでは恒常性）を直接実装するのではなく、下位の現象を実装することを介して、実現したい上位の現象を創発する、という手法をとる必要があります。本作ではセルオートマトンの状態遷移ルールを適切に設定することによりそれを実現しました。\n要件 系の要件 a. 比較的単純かつ小規模な計算で実現できること b. 現れるパターンがConway\u0026rsquo;s Game of Lifeより安定していること a.モデルの単純さと計算しやすさの要件からセルオートマトンを選択し、b.パターン安定の要件から近傍半径を増やして近傍セルひとつあたりのパターンへの影響度を小さくすることにしました。\nセルオートマトンのルール要件 c. 恒常性をもつパターンが発生しうること c1. 系全体では、自然な行いに任せていると秩序が失われること（現実世界でのエントロピーの増大則と同等の仕組み） c2. そのような系のなかで、外界に影響されない区画が存在すること c21. その区画の境界部分が外界の影響を打ち消し、内部に伝えない役割を果たすこと 現実の現象を参考にこれらの要件を満たすルールを考えると、水中の油滴、あるいは泡を抽象化することで理解しやすいモデルを作れそうに思えます。泡状のパターンの境界付近で外界の影響を打ち消し、内部に恒常性をつくる、という構造です。\n実装仕様 実装: MembraneAutomata - GitHub\nMNCAの実装 MembraneAutomataで実装するMNCAは近傍半径を2以上に拡張したものです。自セルの次の状態に影響する近傍セル数 n 近傍半径を r と置いたとき\nn = (r * (r + 1)) * 4","keywords":["homeostasis","cellular_automata","membrane_automata","research"],"articleBody":" これは学生の頃、連休中に思い立って書き上げたMacアプリケーションです。\n10年以上前の実装にも関わらず現行マシンで問題なくコンパイルできました。実装言語のObjective-CとCに大きな更新がなかったためかな？\n当時はパターンが収束してしまうことがわかり触るのをやめてしまったのですが、モデルの筋はいい気がするのでパラメータを変えて自動探索にかけたらなにか生まれそうな気がします。\n概要 生命現象の土台となる恒常性をもつパターンが現れうる系を作成しました。今回はモデルと計算の簡便さから、系の基本構造にはセルオートマトンを採用しました。セルオートマトンはConway’s Game of Life[^1]に代表されるように、単純なモデルを比較的少ない計算量で実行できる便利な計算モデルです。しかしパターンの恒常性の観点から考えると、ひとつのセルの状態が反転しただけで崩壊するような不安定なモデルに恒常性をもたせるのは困難です。MembraneAutomataでは近傍半径を増やす[^2]ことで頑強なパターン構築を可能にしました。そしてMNCAの上で、恒常性のある領域を外界から隔離するために、泡状の構造が生成される簡易化学モデルを実装しました。\n^1: Conway’s Game of Life - Wikipedia\n^2: Multiple Neighbourhood Cellular Automata (MNCA)と呼ばれる。Understanding Multiple Neighbourhood Cellular Automata\nMotivation of Current Work 私は生命のもつ予測不能性を再現するというテーマを研究しており、この作品はそのテーマのうえで、恒常性の創発に主眼を置いて作ったものです。予測不能性という制約のもとで設計するためには、実現したい現象（ここでは恒常性）を直接実装するのではなく、下位の現象を実装することを介して、実現したい上位の現象を創発する、という手法をとる必要があります。本作ではセルオートマトンの状態遷移ルールを適切に設定することによりそれを実現しました。\n要件 系の要件 a. 比較的単純かつ小規模な計算で実現できること b. 現れるパターンがConway’s Game of Lifeより安定していること a.モデルの単純さと計算しやすさの要件からセルオートマトンを選択し、b.パターン安定の要件から近傍半径を増やして近傍セルひとつあたりのパターンへの影響度を小さくすることにしました。\nセルオートマトンのルール要件 c. 恒常性をもつパターンが発生しうること c1. 系全体では、自然な行いに任せていると秩序が失われること（現実世界でのエントロピーの増大則と同等の仕組み） c2. そのような系のなかで、外界に影響されない区画が存在すること c21. その区画の境界部分が外界の影響を打ち消し、内部に伝えない役割を果たすこと 現実の現象を参考にこれらの要件を満たすルールを考えると、水中の油滴、あるいは泡を抽象化することで理解しやすいモデルを作れそうに思えます。泡状のパターンの境界付近で外界の影響を打ち消し、内部に恒常性をつくる、という構造です。\n実装仕様 実装: MembraneAutomata - GitHub\nMNCAの実装 MembraneAutomataで実装するMNCAは近傍半径を2以上に拡張したものです。自セルの次の状態に影響する近傍セル数 n 近傍半径を r と置いたとき\nn = (r * (r + 1)) * 4\nと表せます。\nその他の仕様はConway’s Game of Lifeを踏襲し、自セルの次の状態は、自セルの現在の状態と近傍セルの現在の状態の合計値から決定します。\nMembraneAutomataモデル（セルオートマトンのルール） このモデルでは、物質のメタファーとしてセルの状態を表現します。より単純な物質から複雑な物質が合成され、複雑な物質がはより単純な物質に分解されるという仕組みを、状態間で優劣のないセルオートマトンで表現するために、状態遷移の条件に優先順位を設けます。\n状態遷移の条件 状態遷移は\n合成条件: その状態が新たに生成される、もしくはその状態が保たれる条件 分解条件: その状態が保てなくなる条件 の条件に合致した際に発生します。合成・分解条件は状態ごとに複数定義することができます。次状態を計算する際は、全状態分の合成・分解条件を優先度順に照合し、合致した条件を適用して次のセル状態を求めます。全ての状態は分解先の状態をもち、分解条件に合致した場合は分解先状態に遷移します。\n実験 基底状態 全ての現象の基盤となるふたつの状態（水と油のメタファー）、およびその境界面に発生する膜の状態を定義します。\n0状態（水のメタファー, 青） 合成条件：近傍セルの過半数が0(水)である 分解条件：なし（1(油)の合成条件と同じ） 分解先：1(油) 1状態（油のメタファー, 黒） 合成条件：近傍セルの過半数が1(油)である 分解条件：なし（0(水)の合成条件と同じ） 分解先：0(水) 2状態：（膜のメタファー, オレンジ） 合成条件：近傍セルの半数が0(水)である and 近傍セルの半数が1(油)である and 近傍に2(膜)が存在する※ 分解条件：近傍セルの半数が0(水)でない or 近傍セルの半数が1(油)でない 分解先：0(水) ※ 自己触媒となる条件\nある一様の領域と、それを分離するパターンはこのように単純な条件で実現できます。\n移動と内部構造 水、油の基底状態の他に以下の状態を追加しました。\n水滴の移動を実現するために、水領域を拡大する膜(ピンク)、油領域を拡大する膜(オレンジ)を導入 水滴に内部構造をつくるために、水領域内のみで合成される状態(緑)を導入 このルールセットではランダムな初期状態から計算を続けると、移動体が合体して移動方向が揃っていき、波状のパターンに収束するのが観察されました。\nQ. 移動の現象は要件上必須ではないのでは？ A. それはそう 恒常性 前実験で系が収束することがわかったためにここまで到達しませんでしたね。今度やりましょう\n考察 MNCA 近傍半径を増やし近傍セルひとつひとつの影響度を小さくすることでConway’s Game of Lifeより堅牢なパターンを作り出すことは意図通り実現できました。\nMembraneAutomataモデル セルオートマトンの状態遷移を合成・分解条件と抽象化することで、条件を追加していくことで既存の現象を保ったまま新たな複雑な現象を実装していくことができるようになりました。\nこの仕組みの特徴としては以下のものが挙げられます。\n状態（物質）の特徴を保ったまま別の状態や別の合成・分解条件の追加が可能 条件判定の優先度が高ければその状態は安定であり、優先度が低くなるごとに安定性も下がる 合成・分解条件と抽象化した状態遷移の仕組みを採用したことで、パターンを実現するための条件を考えるのが比較的容易 一方で、パターンを直接的に記述できるために、創発性が薄れてしまった点は改善が必要です。\nパターンの恒常性 実験したルールセットでは恒常性のあるパターンが生まれたとは言えませんが、MembraneAutomataモデルは恒常性をもつルールセットを実現可能だと考えています。\nまず、恒常性を実現する前提である、要件c1. 系全体では、自然な行いに任せていると秩序が失われること は\n条件判定の優先度が高ければその状態は安定であり、優先度が低くなるごとに安定性も下がる\nの性質によって、恒常性なしには最も単純な水と油の混合パターンに収束する、といったルールセットを組めば実現できます。\n要件c2. そのような系のなかで、外界に影響されない区画が存在すること も、泡状のパターンとその境界部に発現する状態は組めているため実現可能だと思われます。一方でそのような現象を直接実装することなしに創発させられるかという部分は不安があり、これは実装してみなければ明らかにならない部分です。\nFuture work アプリケーションの実装上の課題 新規の状態遷移の条件を自動で設定できるようにすることで、新たなルールセットの探索を自動化する 近傍セルの影響度を位置によって変化させる[^3]ことで、自セルと同じ状態だがパターン的に接続していない膜面と融合しない膜、といった高度な現象の実現を検証する おそらくパターンの実装の容易さとパターンの創発性は排他な関係にあるので、それが正しいかどうか、どのように兼ね合いを取るのか持続的に検討する ^3: Leniaのkernelと同等の仕組み Lenia - Biology of Artificial Life - arXiv\n","wordCount":"161","inLanguage":"ja-jp","datePublished":"2022-07-30T17:47:03+09:00","dateModified":"2022-07-30T17:47:03+09:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mitsuyoshi-yamazaki.github.io/ja-jp/posts/2022-07-30-174703.671472/"},"publisher":{"@type":"Organization","name":"みつよし手稿","logo":{"@type":"ImageObject","url":"https://mitsuyoshi-yamazaki.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://mitsuyoshi-yamazaki.github.io/ja-jp/ accesskey=h title="みつよし手稿 (Alt + H)">みつよし手稿</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://mitsuyoshi-yamazaki.github.io/ title=English aria-label=English>En</a></li></ul></div></div><ul id=menu><li><a href=https://mitsuyoshi-yamazaki.github.io/ja-jp/search/ title=検索><span>検索</span></a></li><li><a href=https://mitsuyoshi-yamazaki.github.io/ja-jp/posts/ title=投稿一覧><span>投稿一覧</span></a></li><li><a href=https://mitsuyoshi-yamazaki.github.io/ja-jp/tags/ title=タグ><span>タグ</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>MembraneAutomata</h1><div class=post-meta><span title='2022-07-30 17:47:03 +0900 +0900'>7月 30, 2022</span>&nbsp;|&nbsp;Translations:<ul class=i18n_list><li><a href=https://mitsuyoshi-yamazaki.github.io/posts/2022-07-30-174703.671472/>En</a></li></ul></div></header><div class=post-content><p><img loading=lazy src=/images/membraneautomata_000.png alt></p><p>これは学生の頃、連休中に思い立って書き上げたMacアプリケーションです。<br>10年以上前の実装にも関わらず現行マシンで問題なくコンパイルできました。実装言語のObjective-CとCに大きな更新がなかったためかな？<br>当時はパターンが収束してしまうことがわかり触るのをやめてしまったのですが、モデルの筋はいい気がするのでパラメータを変えて自動探索にかけたらなにか生まれそうな気がします。</p><hr><h2 id=概要>概要<a hidden class=anchor aria-hidden=true href=#概要>#</a></h2><p>生命現象の土台となる恒常性をもつパターンが現れうる系を作成しました。今回はモデルと計算の簡便さから、系の基本構造にはセルオートマトンを採用しました。セルオートマトンはConway&rsquo;s Game of Life[^1]に代表されるように、単純なモデルを比較的少ない計算量で実行できる便利な計算モデルです。しかしパターンの恒常性の観点から考えると、ひとつのセルの状態が反転しただけで崩壊するような不安定なモデルに恒常性をもたせるのは困難です。MembraneAutomataでは近傍半径を増やす[^2]ことで頑強なパターン構築を可能にしました。そしてMNCAの上で、恒常性のある領域を外界から隔離するために、泡状の構造が生成される簡易化学モデルを実装しました。</p><p><em>^1: <a href="https://en.wikipedia.org/wiki/Conway's_Game_of_Life">Conway&rsquo;s Game of Life - Wikipedia</a></em><br><em>^2: Multiple Neighbourhood Cellular Automata (MNCA)と呼ばれる。<a href=https://slackermanz.com/understanding-multiple-neighborhood-cellular-automata/>Understanding Multiple Neighbourhood Cellular Automata</a></em></p><h2 id=motivation-of-current-work>Motivation of Current Work<a hidden class=anchor aria-hidden=true href=#motivation-of-current-work>#</a></h2><p>私は生命のもつ予測不能性を再現するというテーマを研究しており、この作品はそのテーマのうえで、恒常性の創発に主眼を置いて作ったものです。予測不能性という制約のもとで設計するためには、実現したい現象（ここでは恒常性）を直接実装するのではなく、下位の現象を実装することを介して、実現したい上位の現象を創発する、という手法をとる必要があります。本作ではセルオートマトンの状態遷移ルールを適切に設定することによりそれを実現しました。</p><h2 id=要件>要件<a hidden class=anchor aria-hidden=true href=#要件>#</a></h2><h3 id=系の要件>系の要件<a hidden class=anchor aria-hidden=true href=#系の要件>#</a></h3><ul><li>a. 比較的単純かつ小規模な計算で実現できること</li><li>b. 現れるパターンがConway&rsquo;s Game of Lifeより安定していること</li></ul><p>a.モデルの単純さと計算しやすさの要件からセルオートマトンを選択し、b.パターン安定の要件から近傍半径を増やして近傍セルひとつあたりのパターンへの影響度を小さくすることにしました。</p><h3 id=セルオートマトンのルール要件>セルオートマトンのルール要件<a hidden class=anchor aria-hidden=true href=#セルオートマトンのルール要件>#</a></h3><ul><li>c. 恒常性をもつパターンが発生しうること<ul><li>c1. 系全体では、自然な行いに任せていると秩序が失われること（現実世界でのエントロピーの増大則と同等の仕組み）</li><li>c2. そのような系のなかで、外界に影響されない区画が存在すること<ul><li>c21. その区画の境界部分が外界の影響を打ち消し、内部に伝えない役割を果たすこと</li></ul></li></ul></li></ul><p>現実の現象を参考にこれらの要件を満たすルールを考えると、水中の油滴、あるいは泡を抽象化することで理解しやすいモデルを作れそうに思えます。泡状のパターンの境界付近で外界の影響を打ち消し、内部に恒常性をつくる、という構造です。</p><h2 id=実装仕様>実装仕様<a hidden class=anchor aria-hidden=true href=#実装仕様>#</a></h2><p>実装: <a href=https://github.com/mitsuyoshi-yamazaki/MembraneAutomata>MembraneAutomata - GitHub</a></p><h3 id=mncaの実装>MNCAの実装<a hidden class=anchor aria-hidden=true href=#mncaの実装>#</a></h3><p>MembraneAutomataで実装するMNCAは近傍半径を2以上に拡張したものです。自セルの次の状態に影響する近傍セル数 <code>n</code> 近傍半径を <code>r</code> と置いたとき</p><p><code>n = (r * (r + 1)) * 4</code></p><p>と表せます。</p><p><img loading=lazy src=/images/membraneautomata_001.png alt></p><p>その他の仕様はConway&rsquo;s Game of Lifeを踏襲し、自セルの次の状態は、自セルの現在の状態と近傍セルの現在の状態の合計値から決定します。</p><h3 id=membraneautomataモデルセルオートマトンのルール>MembraneAutomataモデル（セルオートマトンのルール）<a hidden class=anchor aria-hidden=true href=#membraneautomataモデルセルオートマトンのルール>#</a></h3><p>このモデルでは、物質のメタファーとしてセルの状態を表現します。より単純な物質から複雑な物質が合成され、複雑な物質がはより単純な物質に分解されるという仕組みを、状態間で優劣のないセルオートマトンで表現するために、状態遷移の条件に優先順位を設けます。</p><h4 id=状態遷移の条件>状態遷移の条件<a hidden class=anchor aria-hidden=true href=#状態遷移の条件>#</a></h4><p>状態遷移は</p><ul><li>合成条件: その状態が新たに生成される、もしくはその状態が保たれる条件</li><li>分解条件: その状態が保てなくなる条件</li></ul><p>の条件に合致した際に発生します。合成・分解条件は状態ごとに複数定義することができます。次状態を計算する際は、全状態分の合成・分解条件を優先度順に照合し、合致した条件を適用して次のセル状態を求めます。全ての状態は分解先の状態をもち、分解条件に合致した場合は分解先状態に遷移します。</p><h2 id=実験>実験<a hidden class=anchor aria-hidden=true href=#実験>#</a></h2><h3 id=基底状態>基底状態<a hidden class=anchor aria-hidden=true href=#基底状態>#</a></h3><p>全ての現象の基盤となるふたつの状態（水と油のメタファー）、およびその境界面に発生する膜の状態を定義します。</p><ul><li>0状態（水のメタファー, 青）<ul><li>合成条件：近傍セルの過半数が0(水)である</li><li>分解条件：なし（1(油)の合成条件と同じ）<ul><li>分解先：1(油)</li></ul></li></ul></li><li>1状態（油のメタファー, 黒）<ul><li>合成条件：近傍セルの過半数が1(油)である</li><li>分解条件：なし（0(水)の合成条件と同じ）<ul><li>分解先：0(水)</li></ul></li></ul></li><li>2状態：（膜のメタファー, オレンジ）<ul><li>合成条件：近傍セルの半数が0(水)である and 近傍セルの半数が1(油)である and 近傍に2(膜)が存在する※</li><li>分解条件：近傍セルの半数が0(水)でない or 近傍セルの半数が1(油)でない<ul><li>分解先：0(水)</li></ul></li></ul></li></ul><p><em>※ 自己触媒となる条件</em></p><p><img loading=lazy src=/images/membraneautomata_002.png alt></p><p>ある一様の領域と、それを分離するパターンはこのように単純な条件で実現できます。</p><h3 id=移動と内部構造>移動と内部構造<a hidden class=anchor aria-hidden=true href=#移動と内部構造>#</a></h3><p>水、油の基底状態の他に以下の状態を追加しました。</p><ul><li>水滴の移動を実現するために、水領域を拡大する膜(ピンク)、油領域を拡大する膜(オレンジ)を導入</li><li>水滴に内部構造をつくるために、水領域内のみで合成される状態(緑)を導入</li></ul><p><img loading=lazy src=/images/membraneautomata_003.gif alt></p><p>このルールセットではランダムな初期状態から計算を続けると、移動体が合体して移動方向が揃っていき、波状のパターンに収束するのが観察されました。</p><p><img loading=lazy src=/images/membraneautomata_004.png alt><br><img loading=lazy src=/images/membraneautomata_005.png alt></p><pre tabindex=0><code>Q. 移動の現象は要件上必須ではないのでは？
A. それはそう
</code></pre><h3 id=恒常性>恒常性<a hidden class=anchor aria-hidden=true href=#恒常性>#</a></h3><p>前実験で系が収束することがわかったためにここまで到達しませんでしたね。今度やりましょう</p><h2 id=考察>考察<a hidden class=anchor aria-hidden=true href=#考察>#</a></h2><h3 id=mnca>MNCA<a hidden class=anchor aria-hidden=true href=#mnca>#</a></h3><p>近傍半径を増やし近傍セルひとつひとつの影響度を小さくすることでConway&rsquo;s Game of Lifeより堅牢なパターンを作り出すことは意図通り実現できました。</p><h3 id=membraneautomataモデル>MembraneAutomataモデル<a hidden class=anchor aria-hidden=true href=#membraneautomataモデル>#</a></h3><p>セルオートマトンの状態遷移を合成・分解条件と抽象化することで、条件を追加していくことで既存の現象を保ったまま新たな複雑な現象を実装していくことができるようになりました。</p><p>この仕組みの特徴としては以下のものが挙げられます。</p><ul><li>状態（物質）の特徴を保ったまま別の状態や別の合成・分解条件の追加が可能</li><li>条件判定の優先度が高ければその状態は安定であり、優先度が低くなるごとに安定性も下がる</li><li>合成・分解条件と抽象化した状態遷移の仕組みを採用したことで、パターンを実現するための条件を考えるのが比較的容易</li></ul><p>一方で、パターンを直接的に記述できるために、創発性が薄れてしまった点は改善が必要です。</p><h3 id=パターンの恒常性>パターンの恒常性<a hidden class=anchor aria-hidden=true href=#パターンの恒常性>#</a></h3><p>実験したルールセットでは恒常性のあるパターンが生まれたとは言えませんが、MembraneAutomataモデルは恒常性をもつルールセットを実現可能だと考えています。</p><p>まず、恒常性を実現する前提である、要件c1. <em>系全体では、自然な行いに任せていると秩序が失われること</em> は</p><blockquote><p>条件判定の優先度が高ければその状態は安定であり、優先度が低くなるごとに安定性も下がる</p></blockquote><p>の性質によって、恒常性なしには最も単純な水と油の混合パターンに収束する、といったルールセットを組めば実現できます。</p><p>要件c2. <em>そのような系のなかで、外界に影響されない区画が存在すること</em> も、泡状のパターンとその境界部に発現する状態は組めているため実現可能だと思われます。一方でそのような現象を直接実装することなしに創発させられるかという部分は不安があり、これは実装してみなければ明らかにならない部分です。</p><h2 id=future-work>Future work<a hidden class=anchor aria-hidden=true href=#future-work>#</a></h2><ul><li>アプリケーションの実装上の課題<ul><li>新規の状態遷移の条件を自動で設定できるようにすることで、新たなルールセットの探索を自動化する</li></ul></li><li>近傍セルの影響度を位置によって変化させる[^3]ことで、自セルと同じ状態だがパターン的に接続していない膜面と融合しない膜、といった高度な現象の実現を検証する</li><li>おそらくパターンの実装の容易さとパターンの創発性は排他な関係にあるので、それが正しいかどうか、どのように兼ね合いを取るのか持続的に検討する</li></ul><p><em>^3: Leniaのkernelと同等の仕組み <a href=https://arxiv.org/abs/1812.05433>Lenia - Biology of Artificial Life - arXiv</a></em></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://mitsuyoshi-yamazaki.github.io/ja-jp/tags/homeostasis/>homeostasis</a></li><li><a href=https://mitsuyoshi-yamazaki.github.io/ja-jp/tags/cellular_automata/>cellular_automata</a></li><li><a href=https://mitsuyoshi-yamazaki.github.io/ja-jp/tags/membrane_automata/>membrane_automata</a></li><li><a href=https://mitsuyoshi-yamazaki.github.io/ja-jp/tags/research/>research</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://mitsuyoshi-yamazaki.github.io/ja-jp/>みつよし手稿</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>